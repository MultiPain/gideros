#define _UNUSED(n)

//#include "glog.h"

//#define IM_ASSERT( exp ) \
//    ( (exp) ? (void)0 : glog_v("Failed assertion at %s:%d %s\n",  __FILE__,__LINE__, #exp))

#include "gplugin.h"
#include "application.h"
#include "lua.hpp"
#include "luautil.h"
#include "luaapplication.h"
#include "sprite.h"
#include "binder.h"
#include "texturebase.h"
#include "imgui_src/imgui.h"


////////////////////////////////////////////////////////////////////////////////
///
/// HELPERS
///
////////////////////////////////////////////////////////////////////////////////

double getfield(lua_State *L, const char *key)
{
    lua_pushstring(L, key);
    lua_gettable(L, -2);  // get table[key]
    double result = lua_tonumber(L, -1);
    lua_pop(L, 1);  // remove number
    return result;
}

////////////////////////////////////////////////////////////////////////////////

static char keyWeak = ' ';
static lua_State *L;

class GImGui
{
public:
    GImGui(LuaApplication* application, lua_State *L);
    ~GImGui();

    SpriteProxy *proxy;

    void doDraw(const CurrentTransform&, float sx, float sy, float ex, float ey);
private:
    LuaApplication* application;
    //lua_State *L;
    struct _Color {
        uint8_t r,g,b,a;
    };
    VertexBuffer<Point2f> vertices;
    VertexBuffer<Point2f> texcoords;
    VertexBuffer<_Color> colors;
};

static void _Draw(void *c, const CurrentTransform&t, float sx, float sy,
        float ex, float ey) {
    ((GImGui *) c)->doDraw(t, sx, sy, ex, ey);
}

static void _Destroy(void *c) {
    delete ((GImGui *) c);
}

GImGui::GImGui(LuaApplication* application, lua_State *L)
{
    Binder binder(L);
    int swidth=luaL_checkinteger(L,1);
    int sheight=luaL_checkinteger(L,2);

    this->application = application;
    proxy = gtexture_get_spritefactory()->createProxy(application->getApplication(), this, _Draw, _Destroy);

    // init ImGui itself
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();

    // Setup style theme
    ImGui::StyleColorsDark();


    // Create font
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

    g_id texture = gtexture_create(width, height, GTEXTURE_RGBA, GTEXTURE_UNSIGNED_BYTE, GTEXTURE_CLAMP, GTEXTURE_NEAREST, pixels, NULL, 0);
    io.Fonts->TexID = (void *)texture;

    io.DisplaySize.x = swidth;
    io.DisplaySize.y = sheight;

}

GImGui::~GImGui()
{

    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->TexID = 0;
    ImGui::DestroyContext();
}

void GImGui::doDraw(const CurrentTransform&, float _UNUSED(sx), float _UNUSED(sy), float _UNUSED(ex), float _UNUSED(ey))
{
    ImDrawData* draw_data = ImGui::GetDrawData();
    if (!draw_data) return;
    ShaderEngine *engine=gtexture_get_engine();
    ShaderProgram *shp=engine->getDefault(ShaderEngine::STDP_TEXTURECOLOR);
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
       const ImDrawList* cmd_list = draw_data->CmdLists[n];
       const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
       const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
       size_t vtx_size=cmd_list->VtxBuffer.Size;
       vertices.resize(vtx_size);
       texcoords.resize(vtx_size);
       colors.resize(vtx_size);
       for (size_t i=0;i<vtx_size;i++) {
           vertices[i].x=vtx_buffer[i].pos.x;
           vertices[i].y=vtx_buffer[i].pos.y;
           texcoords[i].x=vtx_buffer[i].uv.x;
           texcoords[i].y=vtx_buffer[i].uv.y;
           uint32_t c=vtx_buffer[i].col;
           uint32_t a=(c&0xFF000000)>>24;
           uint32_t b=(c&0xFF0000)>>16;
           uint32_t g=(c&0xFF00)>>8;
           uint32_t r=(c&0xFF)>>0;
           colors[i].b=(b*a)>>8;
           colors[i].g=(g*a)>>8;
           colors[i].r=(r*a)>>8;
           colors[i].a=a;
       }
       vertices.Update();
       texcoords.Update();
       colors.Update();
       shp->setData(ShaderProgram::DataVertex, ShaderProgram::DFLOAT,2, &vertices[0], vtx_size, true, NULL);
       shp->setData(ShaderProgram::DataTexture, ShaderProgram::DFLOAT,2, &texcoords[0], vtx_size, true, NULL);
       shp->setData(ShaderProgram::DataColor, ShaderProgram::DUBYTE,4, &colors[0], vtx_size, true, NULL);

       for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
       {
          const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
          if (pcmd->UserCallback)
          {
              pcmd->UserCallback(cmd_list, pcmd);
          }
          else
          {
              // The texture for the draw call is specified by pcmd->TextureId.
              // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
              engine->bindTexture(0,gtexture_getInternalTexture((g_id)pcmd->TextureId));
              // We are using scissoring to clip some objects. All low-level graphics API should supports it.
              // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
              //   (some elements visible outside their bounds) but you can fix that once everything else works!
              // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
              //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
              //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github),
              //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
              // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
              ImVec2 pos = draw_data->DisplayPos;
              engine->pushClip((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));
              // Render 'pcmd->ElemCount/3' indexed triangles.
              // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
              shp->drawElements(ShaderProgram::Triangles, pcmd->ElemCount,ShaderProgram::DUSHORT, idx_buffer,true,NULL);
              engine->popClip();
         }
         idx_buffer += pcmd->ElemCount;
       }
    }

}

int initImGui(lua_State *L)
{
    LuaApplication* application = static_cast<LuaApplication*>(luaL_getdata(L));
    Binder binder(L);

    GImGui *imgui = new GImGui(application, L);
    binder.pushInstance("ImGui", imgui->proxy);

    luaL_rawgetptr(L, LUA_REGISTRYINDEX, &keyWeak);
    lua_pushvalue(L, -2);
    luaL_rawsetptr(L, -2, imgui);
    lua_pop(L, 1);

 //    lua_getglobal(L, "ImGui");
//    lua_pushnumber(L, width);
//    lua_setfield(L, -2, "textureWidth");
//    lua_pushnumber(L, height);
//    lua_setfield(L, -2, "textureHeight");
//    lua_pushlstring(L, (char *)pixels, width * height * 4);
//    lua_setfield(L, -2, "texturePixels");

    return 1;
}

int destroyImGui(lua_State *L)
{
//    lua_getglobal(L, "ImGui");
//    lua_pushnil(L);
//    lua_setfield(L, -2, "textureWidth");
//    lua_pushnil(L);
//    lua_setfield(L, -2, "textureHeight");
//    lua_pushnil(L);
//    lua_setfield(L, -2, "texturePixels");

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
///
/// RENDERER
///
////////////////////////////////////////////////////////////////////////////////

// Example
/*
    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
     }
*/

void MyImGuiRenderFunction(ImDrawData* draw_data)
{
    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    ImGuiIO& io = ImGui::GetIO();
    int fb_width = (int)(io.DisplaySize.x * io.DisplayFramebufferScale.x);
    int fb_height = (int)(io.DisplaySize.y * io.DisplayFramebufferScale.y);
    if (fb_width == 0 || fb_height == 0)
        return;
    draw_data->ScaleClipRects(io.DisplayFramebufferScale);
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {

    }
}

////////////////////////////////////////////////////////////////////////////////
///
/// BINDINGS
///
////////////////////////////////////////////////////////////////////////////////

/// INPUTS

int ImGui_impl_MouseHover(lua_State *L)
{
    ImGuiIO& io = ImGui::GetIO();
    io.MousePos.x = getfield(L, "x");
    io.MousePos.y = getfield(L, "y");

    return 0;
}

int ImGui_impl_MouseDown(lua_State *L)
{
    IM_ASSERT("My message");

    int button = (int)getfield(L, "button");

    // shift 1 bit to translate gideros buttons: 1, 2, 4
    // to ImGui buttons: 0, 1, 2
    button >>= 1;

    ImGuiIO& io = ImGui::GetIO();
    io.MousePos.x = getfield(L, "x");
    io.MousePos.y = getfield(L, "y");
    io.MouseDown[button] = true;

    return 0;
}

int ImGui_impl_MouseUp(lua_State *L)
{
    int button = (int)getfield(L, "button");

    // shift 1 bit to translate gideros buttons: 1, 2, 4
    // to ImGui buttons: 0, 1, 2
    button >>= 1;

    ImGuiIO& io = ImGui::GetIO();
    io.MousePos.x = getfield(L, "x");
    io.MousePos.y = getfield(L, "y");
    io.MouseDown[button] = false;

    return 0;
}

int ImGui_impl_MouseWheel(lua_State *L)
{
    float wheel = getfield(L, "wheel");

    ImGuiIO& io = ImGui::GetIO();
    io.MouseWheel = wheel;

    return 0;
}

/// DRAWING STUFF

int ImGui_impl_NewFrame(lua_State *L)
{
    double deltaTime = getfield(L, "deltaTime");

    ImGuiIO& io = ImGui::GetIO();
    io.DeltaTime = deltaTime;

    ImGui::NewFrame();
    //ImGui::ShowMetricsWindow();

    return 0;
}

int ImGui_impl_Render(lua_State *L)
{
    ImGui::Render();
    return 0;
}

int ImGui_impl_EndFrame(lua_State *L)
{
    ImGui::EndFrame();
    return 0;
}

// TODO: ImGuiWindowFlags arg
int ImGui_impl_Begin(lua_State *L)
{
    const char *name = luaL_checkstring(L, 2);

    ImGui::Begin(name);

    return 0;
}

int ImGui_impl_End(lua_State *L)
{
    ImGui::End();
    return 0;
}

int ImGui_impl_Text(lua_State *L)
{
    const char *text = luaL_checkstring(L, 2);

    ImGui::Text("%s",text);
    return 0;
}


int loader(lua_State *L)
{
    Binder binder(L);
    const luaL_Reg functionList[] =
    {
        // Mouse inputs
        {"onMouseHover", ImGui_impl_MouseHover},
        {"onMouseDown", ImGui_impl_MouseDown},
        {"onMouseUp", ImGui_impl_MouseUp},
        {"onMouseWheel", ImGui_impl_MouseWheel},

        // Touch inputs TODO

        // Keyboard inputs TODO

        // Styles

        // Text
        {"Text", ImGui_impl_Text},

        {"Begin", ImGui_impl_Begin},
        {"End", ImGui_impl_End},

        // Render
        {"NewFrame", ImGui_impl_NewFrame},
        {"Render", ImGui_impl_Render},
        {"EndFrame", ImGui_impl_EndFrame},
        {NULL, NULL}
    };

    binder.createClass("ImGui", "Sprite", initImGui, destroyImGui, functionList);

    luaL_newweaktable(L);
    luaL_rawsetptr(L, LUA_REGISTRYINDEX, &keyWeak);

    // TODO:
    // Enums

    return 1;
}

static void g_initializePlugin(lua_State *L)
{
    ::L = L;
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "preload");

    lua_pushcfunction(L, loader);
    lua_setfield(L, -2, "ImGui");

    lua_pop(L, 2);

}

static void g_deinitializePlugin(lua_State *_UNUSED(L)) {  }

REGISTER_PLUGIN_NAMED("ImGui", "1.0.0", imgui)
